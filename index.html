<script src="https://raw.github.com/LearnBoost/socket.io-client/master/dist/socket.io.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js"></script>
<style>
	#box {
		background: red;
		width: 200px;
		height: 200px;
	}
</style>
<div id="box"></div>
<a id="download"></a>
<script>		
	var extend = function(base, ext) {
		for( var k in ext ) {
			base[k] = ext[k];
		}
	};
	
	/***********************
	****************** Views
	************************/
	var DropView = function(el) {
		extend(this, {
			listen: function(evt, cb) {
				el.bind(evt, cb);
			}
		});
	};	
	var DisplayView = function(el) {
		extend(this, {
			update: function(file) {
				el.attr('href', file.url);
				el.attr('download', file.name);
				el.text(file.content);
			}
		});	
	};

	/***********************
	************ Controllers
	************************/
	var Sender = function(view, model) {			
		// handle drag-n-drop
		var socket = model.socket;
		var channel = model.channel;
		var buffer = [];	
		var send = function(msg) {
			socket.emit(channel, msg);
		};
		var endPoint = function(start, file) {
			return start+250>file.size?file.size-1:start+250;
		};
		var readBlob = function(file, cb, opt_startByte, opt_stopByte) {
			var start = opt_startByte || 0;
			var end = opt_stopByte || endPoint(start, file);		
			var reader = new FileReader();		
			reader.onloadend = function(evt) {
				if (evt.target.readyState == FileReader.DONE) {
					var last = opt_stopByte==file.size-1;
					var first = opt_startByte==0;
					cb(evt.target.result, first, last);		
					if( end < file.size-1 ) {
						// recurse
						readBlob(file, cb, end+1, endPoint(end+1, file));
					}
				}
			};		
			var blob = file.slice(start, end + 1);
			reader.readAsArrayBuffer(blob);				
		};
		var dropHandler = function(e) {    
		    e.originalEvent.preventDefault();
		    var file = e.originalEvent.dataTransfer.files[0];
		    send({ state: 3, payload: {
		    	size: file.size,
		    	filename: file.name
		    } });
		    
			readBlob(file, function(data, first, last) {
				// send data
				var buffer = [];
				[].push.apply(buffer, new Uint8Array(data));
				send({
					state: first?0:(last?2:1), 
					payload: buffer
				});
			});
		};
		extend(this, {
			init: function() {
				view.listen('drop', dropHandler);
				return this;
			}
		});
	};
	var Saver = function(view, model) {		
		// handle transmitted file
		var socket = model.socket;
		var channel = model.channel;
		var buffer = [];
		var size, filename;
		var errorHandler = function(e) {
			var errors = ["QUOTA_EXCEEDED", "NOT_FOUND", "SECURITY", "INVALID_MODIFICATION", "INVALID_STATE"].map(function(error) {
				return e.code == FileError[error+"_ERR"] ? error : "";
			});
			console.log(errors.join(""));
		};
		var fileRespHandler = function(blob, cb) {
			return function(fs) {
				fs.root.getFile('log.txt', {create: true}, function(fileEntry) {
					// Create a FileWriter object for our FileEntry (log.txt).
					fileEntry.createWriter(function(fileWriter) {
						fileWriter.onwriteend = cb;
						fileWriter.onerror = cb;
						fileWriter.write(blob);
						
						view.update({
							url: fileEntry.toURL(),
							name: filename,
							content: "Download"
						});
					}, errorHandler);
				}, errorHandler);
			};
		};
		var saveToFile = function(blob, cb) {
			window.webkitRequestFileSystem(window.TEMPORARY, 1024*1024, fileRespHandler(blob, cb), errorHandler);
		};
		var bufferHandler = function(buffer) {
			var arraybuffer = (new Uint8Array(buffer));
			var blob = new Blob([arraybuffer], {type: 'text/plain'});
			saveToFile(blob, function(e) {
				console.log("saved");
			});
		};
		var packetHandler = function(msg) {
			if( msg.state == 3 ) {
				size = msg.payload.size;
				filename = msg.payload.filename;
			} else {
				if( msg.state == 0 ) { // first
					buffer = [];				
				}
				[].push.apply(buffer, msg.payload);			
				if( msg.state == 2 ) { // last
					bufferHandler(buffer);
				}
			}			
		};
		extend(this, {
			init: function() {
				socket.on(channel, packetHandler);
				socket.emit('initiate', { channel: channel });
				return this;
			}
		});
	};
	
	/***********************
	****************** Setup
	************************/
	(function() {
		var socket = io.connect('http://localhost:8080', {
			'reconnect': true,
			'reconnection delay': 500,
			'max reconnection attempts': 10
		});
		var sender = new Sender(new DropView($("#box")), {
			channel: "abcd",
			socket: socket
		}).init();
		var saver = new Saver(new DisplayView($("#download")), {
			channel: "abcd",
			socket: socket
		}).init();
	})();
</script>